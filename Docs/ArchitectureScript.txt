____________________________________________________
		Arhitectura
____________________________________________________

Sa fac un contract intre fiecare 2 membri care interactioneza.
Pentru relatia Apiary -> TownHall sa fie un contract care contine metode accesibile ambelor entitati.
Daca vreau sa reconstruiesc drumul inapoi catre un membru, de ex, de la Consumer la Apiry, merg din contract in contract, inapoi, cu un algoritm: vad lotul din magazin, apoi lotul din depozit, lotul de la transportator, lot din depozit, lotul creat de procesator, id mierii din centrul de achizitie si apoi din acel id catre Apiary si sa returneze informatia dorita. (din id in id) 
Acest algoritm are pasi stabiliti, si utilizatorul curent obtine informatiile printr-un lant de chei general.

____________________________________________________
		Smart contracts
	1.  ApiaryTownHallSCM
	2.  ApiaryAcquisitionCenterSCM
	3.  AcquisitionCenterLaboratorySCM
	4.  AcquisitionCenterProcessorSCM
	5.  ProcessorStorageProcessorSCM
	6.  StorageProcessorTransportSCM
	7.  TransportPharmaceuticalSCM
	8.  TrasportWarehouseStoreSCM
	9.  WarehouseStoreUnitSaleSCM
	10. UnitSaleConsumerSCM

Path-ul pentru informatii este construit din id-uri (stupina, miere, lot)

Link: https://docs.soliditylang.org/en/v0.8.6/solidity-by-example.html#safe-remote-purchase
____________________________________________________


Pentru fiecare membru trebuie o interfata pentru actiunie sale ca membru in lantul de aprovizionare si o interfata pentru vizioare, pentru interogare blockchain.


???
Modelul smart contract-ului este State machine.
Aplicatia realizeaza tranzitii intre starile definite in solutie.
Fiecare membru reprezinta o stare a sistemului, cu date de intrare si date de iesire. Datele de intrare influenteaza stare curenta si datele de iesire influenteaza starea urmatoare a sistemului.

Generalitati intr-un state machine smart contract:
- Un enum cu starile sistemului.
- Unul/mai multi modificatori care sa limiteze accesul la o anumita stare.
Exemplu:
contract StateMachineExample is ... {
    enum States { 
        AwaitQuestion, GotQuestion, AwaitAnswer, GotAnswer }
    
    States public state = States.AwaitQuestion;
    
    modifier onlyState(States expected) {
        require(state == expected, "Not permitted in this state");
        _;
    }
    function setQuestion() public onlyState(States.AwaitQuestion) {
        state = States.GotQuestion;
    }
    
    function getQuestion() public onlyState(States.GotQuestion) {
        state = States.AwaitAnswer;
    }
    
    function setAnswer() public onlyState(States.AwaitAnswer) {
        state = States.GotAnswer;
    }
    
    function getAnswer() public onlyState(States.GotAnswer) {
        state = States.AwaitQuestion;
    }
}

Drawbacks:
1. Daca lantul incepe cu un produs, nu mai poate fi inceput altul pana nu se termina cel actual. Pentru a evita, ori facem deploy la mai multe smart contracts(rau), ori folosim coada de prioritati.
2. Consumul de Gas si costurile de memorare pentru datele din blockchain









____________________________________________________
		Algoritm executie
____________________________________________________
1. START
2. Stupina inregistreaza in Blockchain o noua intrare de miere.
3. Daca Stupina nu are o licenta valida, atunci Primaria creeaza o noua licenta, altfel sari la pasul 5.
4. Primaria genereaza si returneaza o noua licenta valida pentru stupina solicitanta.
5. Centrul de achizitie preia mierea de la Stupina.
6. O proba de miere este trimisa catre Laboratorul de analize, unde sunt testate calitatile si proprietatile mierii.
7. Laboratorul intoarce catre Centrul de achizitie un rezultat sub forma de raport, in maxim 24 de ore de la primirea probei.
8. Centrul de achizitie analizeaza raportul si ia decizia de a trimite mai departe mierea catre procesator (in maxim 24 de ore de la primirea raportului - in total 48 h pana cand mierea ajunge la procesator), sau de a returna mierea catre stupina (Stop lant de aprovizionare).
9. Procesatorul aduna mierea cu proprietati foarte apropiate, in cantitati mai mari si formeaza loturi de miere.
10. Aceste loturi sunt pregatite de imbuteliere, impachetare si transport. Un neajuns este faptul ca poate exista transport intre toti membri lantului de aprovizionare, nu doar de la procesator la magazine.
11. Procesatorul elibereaza un raport privind calitatea, filtrarea, incalzirea, impachetarea mierii.
12. Mierea poate merge spre depozitul procesatorului pentru o vanzare ulterioara sau direct la firma de transport care distribuie mierea catre urmatorii membri.
13. Daca mierea a fost depozitata un timp mai mare de 3 zile la procesator, trebuie sa se elibereze un raport de calitate privind conditiile de pastrare.
14. Firma de transport incarca loturile de miere si le distribuie spre depozitul magazinului destinatie sau catre companii farmaceutice/cosmetice.
15. Firma de transport elibereaza un raport/nota de livrare catre entitatea destinatie.
16. Din depozit, borcanele de miere sunt expuse in magazin, si un raport cu privire la calitatea pastrarii in depozitul magazinului este eliberat.
17. Mierea expusa in magazin este destinata consumatorilor care cumpara de la magazinele cu sistemul de gestionare integrat.
18. Consumatorul poate verifica inainte calitatea mierii, prin accesare online si vizualizarea raportului integrat in pagina web sau prin scanarea unui cod QR cu camera telefonului si vizualizarea in browser-ul telefonului mobil.
19. STOP
________________________________________________


________________________________________________
		Actori
________________________________________________

Tip originator = actorul care porneste lantul de aprovizionare si tine evidenta pe parcurs. Acesta defineste conditiile principale pentru fiecare membru, asemanator unui master, care se transforma ulterior intr un contract master.

Tip supplier = actorul care reprezinta membru lantului de aprovizionare care lucreaza cu contract master-ul.
	Fiecare actor supplier are use case-uri separate



________________________________________________
		Continut rapoarte
________________________________________________

Continut certificat de producator:
	Numar de identificare unic la Primarie
	Numele producatorului
	Adresa producatorului
	Numele stupinei 
	Adresa stupinei
	Tipuri de miere certificate
	Valabilitate in luni
	Data eliberarii

Continut rezultat analize:
	Numar unic de identificare
	Este sau nu miere ecologica?
	Pretul analizei
	Data realizarii analizei

Continut raport eliberat de procesator:
	Numar unic de identificare
	Numar identificare lot miere
	Conditiile de incalzire
	Conditiile de filtrare
	Conditiile de impachetare
	Conditiile de depozitare/pastrare
	Data eliberarii

Continut raport eliberat de depozitul procesatorului:
	Numar unic de identificare
	Numar identificare lot miere
	Conditiile de depozitare
	Data eliberarii

Continut raport transportator/note livrare:
	Numar unic de identificare
	Cantitate transportata
	Locul plecarii
	Destinatia
	Continut transport
	Data incarcarii
	Data descarcarii
	Conditii transport
	Pret

Continut raport eliberat de depozitul magazinului:
	Numar unic de identificare
	Numar identificare lot
	Durata pastrare in depozit
	Data intrare depozit
	Conditii pastrare




* in schema veche aveam o problema:
verificam daca mierea e bio la procesator, dar mai bine aceasta decizie o ia centrul de achizitie.

__!_!_!_!______________________________________

Scriu tot codul intr-un contract cu membri ca metode si cu o variabila comuna tutoror.
_______________________________________________

Fiecare membru are un numar de ordine, adica
	Townhall are 1
	Apiary are 2
	Acquisition center are 3 ...
Cand vrem sa verificam la ce pas suntem, aplicam 
	require(step == id_member)

Un Honey object nou este creat la Apiary member si arata astfel:

{
	1,
	PopescuAppiaryation,
	[0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
	8 July 2021,
	0xfeeef3923529efacccbd
}

* performAction reprezeinta un array
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
[1, 1, 1, 1, 0, 0, 0, 0, 0, 0] inseamna ca obiectul a trecut de primi patru membri din supply chain

* _nameBeekeeper&nameApiary inseamna numele apicultorului concatenat cu numele stupinei, care reprezinta un identificator unic pentru o intrare in supply chain

	Dupa ce s-a executat Apiary member, verific daca exista o licenta valida, daca da, merg mai departe, daca nu, execut Townhall member si creez o noua licenta.
	La acquisition center la fel, la inceput am anlizele nule, apoi merg mai departe catre Laboratory sa le prelucrez. Intorc rezultatele si apoi mierea merge la apiary daca nu e buna sau la procesator daca e ecologica